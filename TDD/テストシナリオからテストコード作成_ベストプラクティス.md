# テストシナリオからテストコード作成までのベストプラクティス

生成AI×TDDアプローチに基づく実践ガイド

---

## 1. テストシナリオ作成の基本

### 1.1 ユーザーストーリーからテストシナリオへ

ユーザーストーリーは以下のテンプレートで記述する:

```
<誰が>として、<何を>したい。それは<なぜならば>。
```

**例:**
```
管理者として、ユーザーアカウントを停止したい。それは不正利用を防ぐためだ。
```

### 1.2 INVESTモデルによるストーリーの品質確認

良いユーザーストーリーは以下の特性を満たす:

| 特性 | 説明 | チェックポイント |
|------|------|-----------------|
| **I**ndependent | 独立している | 他のストーリーに依存せず単独で完了できるか |
| **N**egotiable | 交渉可能 | 実装方法を柔軟に議論できるか |
| **V**aluable | 価値がある | ユーザーに認識できる価値を提供するか |
| **E**stimable | 見積もり可能 | チームが作業量を予測できるか |
| **S**mall | 小さい | 1スプリントで完了できるサイズか |
| **T**estable | テスト可能 | 実装の成否を確認できるか |

### 1.3 受け入れ基準の定義（Given-When-Then形式）

受け入れ基準はGherkin形式で記述する:

```gherkin
Feature: ユーザーアカウント停止機能

  Scenario: 管理者が不正ユーザーを停止する
    Given 管理者としてログインしている
    And 対象ユーザーが「アクティブ」状態である
    When ユーザー詳細画面で「アカウント停止」ボタンをクリックする
    Then ユーザーのステータスが「停止」に変更される
    And ユーザーにメール通知が送信される
    And 監査ログに停止操作が記録される
```

---

## 2. テストリストの作成

### 2.1 テストリストとは

TDDでは実装前に「テストリスト」を作成する。これはテストシナリオを網羅的にリスト化したもの。

**テストリストの例:**
```markdown
## ユーザーアカウント停止機能

### 正常系
- [ ] アクティブユーザーを停止できる
- [ ] 停止時にメール通知が送信される
- [ ] 監査ログに記録される

### 異常系
- [ ] 既に停止済みのユーザーは再停止できない
- [ ] 管理者以外は停止操作ができない
- [ ] 自分自身のアカウントは停止できない

### 境界値
- [ ] 停止理由が空の場合はエラー
- [ ] 停止理由が1000文字を超える場合はエラー
```

### 2.2 AIを活用したテストリスト拡充

生成AIにテストケースの探索を依頼する際のプロンプト例:

```
以下のユーザーストーリーに対して、考慮すべきテストケースを網羅的にリストアップしてください。
正常系、異常系、境界値、エッジケースを含めてください。

ユーザーストーリー:
管理者として、ユーザーアカウントを停止したい。それは不正利用を防ぐためだ。

受け入れ基準:
- ユーザーのステータスが「停止」に変更される
- ユーザーにメール通知が送信される
- 監査ログに停止操作が記録される
```

---

## 3. テストコード作成の実践

### 3.1 TDDサイクル（Red-Green-Refactor）

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│    ┌───────┐     ┌───────┐     ┌────────────┐     │
│    │  Red  │ ──> │ Green │ ──> │ Refactor   │     │
│    │(失敗) │     │(成功) │     │(リファクタ)│     │
│    └───────┘     └───────┘     └────────────┘     │
│         ^                             │            │
│         │                             │            │
│         └─────────────────────────────┘            │
│                                                     │
└─────────────────────────────────────────────────────┘
```

1. **Red**: 失敗するテストを先に書く
2. **Green**: テストを通す最小限のコードを書く
3. **Refactor**: コードを整理・改善する

### 3.2 ユニットテストの基本構造

**良いユニットテストの原則（F.I.R.S.T.）:**

| 原則 | 説明 |
|------|------|
| **F**ast | 高速に実行できる |
| **I**ndependent | 他のテストに依存しない |
| **R**epeatable | 何度実行しても同じ結果 |
| **S**elf-validating | 自動で成否を判定 |
| **T**imely | プロダクションコードの前に書く |

**テストコードの基本構造（AAA パターン）:**

```typescript
describe('UserService', () => {
  describe('suspendUser', () => {
    it('アクティブユーザーを停止できる', async () => {
      // Arrange（準備）
      const user = createActiveUser();
      const repository = new MockUserRepository([user]);
      const service = new UserService(repository);

      // Act（実行）
      await service.suspendUser(user.id, '不正利用のため');

      // Assert（検証）
      const updatedUser = await repository.findById(user.id);
      expect(updatedUser.status).toBe('suspended');
    });
  });
});
```

### 3.3 AIを活用したテストコード生成

**効果的なプロンプトの要素:**

1. **テスト対象を明確に指定**
2. **期待される振る舞いを具体的に記述**
3. **入力例を提示**
4. **使用するテストフレームワークを指定**

**プロンプト例:**

```
以下の仕様に基づいてJestのテストコードを生成してください。

テスト対象: UserService.suspendUser()
テストフレームワーク: Jest + TypeScript
振る舞い:
- ユーザーIDと停止理由を受け取る
- ユーザーのステータスを「suspended」に変更する
- 変更をリポジトリに保存する
- 成功時はtrueを返す

入力例:
- userId: "user-123"
- reason: "不正利用のため"

考慮すべきケース:
- 正常系: アクティブユーザーの停止成功
- 異常系: 存在しないユーザーID
- 異常系: 既に停止済みのユーザー
```

---

## 4. ATDDにおける受け入れテスト

### 4.1 受け入れテストの位置づけ

```
┌─────────────────────────────────────────────────────┐
│  ユーザーストーリー                                  │
│       ↓                                             │
│  受け入れ基準（Given-When-Then）                    │
│       ↓                                             │
│  受け入れテスト（E2E/統合テスト）  ← ATDD          │
│       ↓                                             │
│  ユニットテスト                    ← TDD           │
│       ↓                                             │
│  プロダクションコード                               │
└─────────────────────────────────────────────────────┘
```

### 4.2 受け入れテストコードの例

```typescript
// Cucumber + TypeScript の例
import { Given, When, Then } from '@cucumber/cucumber';

Given('管理者としてログインしている', async function() {
  await this.loginAs('admin');
});

Given('対象ユーザーが「アクティブ」状態である', async function() {
  this.targetUser = await this.createUser({ status: 'active' });
});

When('ユーザー詳細画面で「アカウント停止」ボタンをクリックする', async function() {
  await this.navigateTo(`/users/${this.targetUser.id}`);
  await this.click('button[data-testid="suspend-user"]');
  await this.confirmDialog();
});

Then('ユーザーのステータスが「停止」に変更される', async function() {
  const user = await this.api.getUser(this.targetUser.id);
  expect(user.status).toBe('suspended');
});
```

---

## 5. 生成AIとの協働ワークフロー

### 5.1 AIにテストを渡してコードを生成させる

**推奨ワークフロー:**

```
1. 人間: テストリストを作成
2. 人間: 最初のテストコードを書く（Red）
3. AI:   テストを通すコードを生成
4. 人間: テスト実行・結果確認（Green）
5. AI:   リファクタリング提案
6. 人間: レビュー・承認
7. 繰り返し
```

### 5.2 テストコードをAIへのプロンプトとして活用

テストコード自体が最高の「プロンプト」になる:

```typescript
// このテストコードをAIに渡す
describe('calculateTax', () => {
  it('10%の消費税を計算する', () => {
    expect(calculateTax(1000)).toBe(100);
  });

  it('小数点以下は切り捨て', () => {
    expect(calculateTax(999)).toBe(99);
  });

  it('0円の場合は0を返す', () => {
    expect(calculateTax(0)).toBe(0);
  });

  it('負の値はエラー', () => {
    expect(() => calculateTax(-100)).toThrow('金額は0以上である必要があります');
  });
});
```

**AIへの指示:**
```
上記のテストコードを全て通過する calculateTax 関数をTypeScriptで実装してください。
```

### 5.3 AIレビューエージェントの活用

生成されたコードは必ずレビューする:

**チェックリスト:**
- [ ] テストが意図を正確に捉えているか
- [ ] エッジケースが網羅されているか
- [ ] コードにバグやセキュリティ脆弱性がないか
- [ ] コーディング規約に準拠しているか
- [ ] 過剰な実装になっていないか

---

## 6. テストコード品質向上のポイント

### 6.1 テストの可読性

```typescript
// Bad: 何をテストしているか分かりにくい
it('test1', () => {
  const r = fn(1, 2);
  expect(r).toBe(3);
});

// Good: テスト名と構造が明確
it('2つの正の整数を足すと合計値を返す', () => {
  // Arrange
  const a = 1;
  const b = 2;

  // Act
  const result = add(a, b);

  // Assert
  expect(result).toBe(3);
});
```

### 6.2 テストの独立性

```typescript
// Bad: テスト間で状態を共有
let sharedUser: User;

beforeAll(() => {
  sharedUser = createUser();
});

it('テスト1', () => {
  sharedUser.name = 'changed'; // 他のテストに影響
});

// Good: 各テストで独立した状態を持つ
it('テスト1', () => {
  const user = createUser();
  user.name = 'changed';
  // このuserは他のテストに影響しない
});
```

### 6.3 テストカバレッジの考え方

**重要なカバレッジポイント:**

1. **正常系パス**: 主要な機能フロー
2. **異常系パス**: エラーハンドリング
3. **境界値**: 最小値、最大値、閾値
4. **状態遷移**: 各状態間の遷移
5. **ビジネスルール**: 重要なビジネスロジック

---

## 7. 実践チェックリスト

### テストシナリオ作成時
- [ ] ユーザーストーリーが明確に定義されている
- [ ] INVESTモデルで品質を確認した
- [ ] Given-When-Then形式で受け入れ基準を記述した
- [ ] 正常系・異常系・境界値を網羅したテストリストがある

### テストコード作成時
- [ ] テストを先に書いている（TDD）
- [ ] F.I.R.S.T.原則に従っている
- [ ] AAA（Arrange-Act-Assert）パターンで構造化している
- [ ] テスト名が何をテストしているか明確
- [ ] モックやスタブを適切に使用している

### AI活用時
- [ ] 具体的で明確なプロンプトを与えている
- [ ] テストコードをプロンプトとして活用している
- [ ] AI生成コードを必ずレビューしている
- [ ] 最終的な品質判断は人間が行っている

---

## 8. まとめ

### テストシナリオ→テストコードの流れ

```
1. ユーザーストーリー定義
   ↓
2. 受け入れ基準作成（Given-When-Then）
   ↓
3. テストリスト作成
   ↓
4. AIでテストケース拡充
   ↓
5. ユニットテストコード作成（Red）
   ↓
6. AIでプロダクションコード生成（Green）
   ↓
7. リファクタリング
   ↓
8. 受け入れテスト実行
   ↓
9. レビュー・改善
```

### 重要な原則

1. **テストが先**: プロダクションコードの前にテストを書く
2. **小さく始める**: 1つのテストから始めて徐々に拡充
3. **AIは支援ツール**: 最終判断は人間が行う
4. **継続的改善**: テストコードも品質向上の対象

---

*本ドキュメントは「生成AI×TDDで実現する 新しいアジャイル開発」（ユウタ著）の内容に基づいて作成されました。*
